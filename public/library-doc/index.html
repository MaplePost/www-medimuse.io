<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapleMuse: Maple Muse Index Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MapleMuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Maple Muse Index Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MapleMuse Public Library Interface </p><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) MediMuse LLC - All Rights Reserved 2019 Unauthorized copying of this file, via any medium is strictly prohibited. Proprietary and confidential. United States Patent No. 10,369,323</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Peter J Slack (pslack)</dd></dl>
<h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>MapleMuse is a C++ library that facilitates the conversion of biometric data into music. It is designed as a extensible library designed using modern c++11 and RAII priciples that allows the user to include into real time audio and digital audio workstation environments and it provides tools to bridge the divde between audio frequency processing and biometric signal frequency processing.</p>
<div class="image">
<img src="maplemuse_slide_1.jpg" alt="maplemuse_slide_1.jpg"/>
</div>
<h2><a class="anchor" id="IMapleModel"></a>
The MapleMuse Facade</h2>
<p>There is one main C function to create an <a class="el" href="class_i_maple_model.html" title="Class IMapleModel base class and interface file for MapleModel. ">IMapleModel</a>. Many models can be created you are not limited to just one model. The expose C functions are used to maintain ABI stablility The model pointers are used to create all other obejcts and interconnectivity between objects. The library is a factory that creates several objects that facilitate this conversion process. The main components that interact and are created by the factory facade are shown in the following diagram</p>
<p>Here's how to create a model facade using her public interface</p>
<div class="fragment"><div class="line"><span class="comment">// First include the main library header</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lib_maple_muse_8h.html">libMapleMuse.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// create a new facade</span></div><div class="line"><a class="code" href="class_i_maple_model.html">IMapleModel</a> *myModel = <a class="code" href="namespacemedimuse.html#ac814201971ebf4c41fa1b3076d852372">create_maple_model</a>(44100);</div><div class="line"></div><div class="line"><span class="comment">// get the uuid of the model</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * modelId = testModel-&gt;get_maple_uuid(myModel);</div><div class="line"></div><div class="line"><span class="comment">// ......</span></div><div class="line"></div><div class="line"><span class="comment">// find the model at some other time</span></div><div class="line"><a class="code" href="class_i_maple_model.html">IMapleModel</a> *whereAmI = find_model(modelId);</div></div><!-- fragment --><p>The pointers returned by the factory are not owned by the caller but are managed by the underlying library as a collection of shared pointers. The caller cannot take ownership of the pointer or extend the lifetime of the pointer. The pointer lives for the lifetime of the shared library. All library functions are thread safe.</p>
<p>The PIMPL idiom was used in the construction of the public interface. the details of how the model and components work is not exposed in the public interface</p>
<p>TODO:// test virtual classes in recompilations</p>
<p>The development is test driven but also integration driven as part of the test platform. So for example, the library CI build system also builds test cases using RTAudio, RTMidi, it also builds the Steinberg VST test suite and tests the VST implementation. Any patterns I choose have to sort of meet all of those integration tests. My rule is to not expose any special types that require outside assistance or headers to compile in the public interface, so not much beyond primitives and raw pointers. I made an exception and started to present templates but, for example, there are no standard library objects in the public interface. So yes I understand about raw pointers but this is sort of a design decision for the public interface to make it as portable as possible to different environments, so for example, returning std::string from any function I wouldn't do in the public interface, the concrete implementation in behind however simply gets the raw pointer from std::string. I don't use raw pointers in behind the interface and it wouldn't be my choice either, this decision is intentional to make it "easier" to integrate in the great wild. This is generally the way I've seen others and common practice in that public interfaces are paired down so as not to require all of the things on the other side of the public interface firewall. The other side of the wall is l standard libraries and I am using c++11. I also use camel case on the other side of the firewall. (still needs some cleanup) , so public facing functions are functions_like_this() .. on the concrete side functions are functionsLikeThis() ...</p>
<p>I am following googles c++ style guide (or trying to) as well.</p>
<p><a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></p>
<p>You can use the library in c++ environment no problems, and that's part of the integration tests, the design and style decision about the public interface is not to include anything that the developer has to add in order to compile and link, the public interface is spartan by design so that the library does not need any extra setup for the user to take advantage of it regardless of the environment they want to use it in. So let's say I decided to pass standard library objects in the public interface, for example std::string, for the consumer of the API they now have to include the header so that their project will actually compile because I have defined std::string but I do not provided that type definition in the interface or in the linkage. By passing const char * instead, now they don't need any extra headers for it to compile. The exercise here is to establish a public interface that is portable and doesn't require anything additional like headers or libraries and doesn't break when we have 1000000 machines and we change the core library internals. Or doesn't break production build systems of companies we might partner with.</p>
<p>I also have test cases to use it in C environments and will work on JNI bindings and bindings to make this a node module.</p>
<p>These design decisions for the public interface based on the PIMPL pattern .. this here explains it a bit <a href="https://cpppatterns.com/patterns/pimpl.html">https://cpppatterns.com/patterns/pimpl.html</a> and I have an example below of a C firewall based on PIMPL</p>
<p>So check this out . <a href="https://github.com/Cycling74/max-mxj/tree/master/source/mxj">https://github.com/Cycling74/max-mxj/tree/master/source/mxj</a></p>
<p>This is the project I worked on, notice the very lonely camel cased .cpp files in that list .. Those are mine. To fit in I used PIMPL and this C to C++ firewall header.</p>
<p><a href="https://github.com/Cycling74/max-mxj/blob/master/source/mxj/IVirtualMachineAPI.h">https://github.com/Cycling74/max-mxj/blob/master/source/mxj/IVirtualMachineAPI.h</a></p>
<p>This means I can do whatever I like basically on the other side of the API firewall and they would not know any difference, so, for example I break into c++ and do a happy dance :-) . the other beauty of C is that there is no name mangling in the symbol tables of the resulting binaries. This means , again, I can change all the c++ to my hearts content, the public symbol table is solid and my resulting binary can be changed or swapped out in places where it is linked in already.</p>
<p>That is a more staunch PIMPL implementation, I relaxed in this one, notice you actually see c++ , however I'm trying another trick with pure virtual in the public interface and concrete classes in behind the firewall, as well subclassed, pure virtual classes. I still want to develop full C bindings as well. But this is where my head is at and I'm open to suggestions, the plumbing is all about fitting in, it's not pretty, maybe it can be prettier than I've done it.</p>
<h2><a class="anchor" id="Inputs"></a>
Creating Input Signals and Input Tracks</h2>
<p>There are two types of inputs that you can create with a model: an input signal (<a class="el" href="class_i_input_signal.html" title="Public interface for a real time biometric input signal. ">IInputSignal</a>) and an input track (<a class="el" href="class_i_input_track.html" title="Public interface for an input track of biometric data. ">IInputTrack</a>). An input signal represents a real time occurance of discrete data points that the user supplies at fixed intervals. An input track represents pre-recorded inputs that are applied as a "playable" track of discrete data points. Currently only a float input signal is supported TODO:// expand to different input signal data types</p>
<p>Once you have created a model facade as in the example above you can use it to create an input signal instance named Fred that is a single dimension, 32 Hz BioSignalType BVP.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a float input signal named Fred that is the type BVP, a single dimension and at a frequency of 32 Hz</span></div><div class="line"></div><div class="line">InputSignal&lt;float&gt;* float_signal = myModel-&gt;<a class="code" href="class_i_maple_model.html#a411929f6d5f1f02ca1b1a3f29f3900c3">create_float_input_signal</a>(<span class="stringliteral">&quot;Fred&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969ea05e46fda0c33b54f2b4d1023e0d56c14">BioSignalType::BVP</a>, 1, 32);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// call the data input at regular intervals</span></div><div class="line"><span class="keywordtype">float</span> **data;</div><div class="line">float_signal-&gt;data_tick(data,CurrentTime::microseconds());</div></div><!-- fragment --><p>An <a class="el" href="class_i_input_track.html" title="Public interface for an input track of biometric data. ">IInputTrack</a> is a subclass of <a class="el" href="class_i_input_signal.html" title="Public interface for a real time biometric input signal. ">IInputSignal</a>. It is an array of input data points that can be "played" automatically. The mechanics of calling the underlying data_tick as in the exmaple above is looked after by the model. The data_tick of the underlying signal is called at the frequency as presented when constructing the input track. To create an input track is as folows:</p>
<div class="fragment"><div class="line"><span class="comment">// create an input track named &quot;Alice&quot; the is a BVP BioSignalType of dimensionality 1 and a frequency of 32 Hz</span></div><div class="line"></div><div class="line"><a class="code" href="class_i_input_track.html">IInputTrack&lt;float&gt;</a>* float_track = myModel-&gt;<a class="code" href="class_i_maple_model.html#a6ee51fa82172af4c7e6f787d2562eaa8">create_float_input_track</a>(<span class="stringliteral">&quot;Alice&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969ea05e46fda0c33b54f2b4d1023e0d56c14">BioSignalType::BVP</a>, 1, 32);</div><div class="line"></div><div class="line"><span class="comment">// parse an Empatica device generated file containing BVP data into the float track</span></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> result = <a class="code" href="namespacemedimuse.html#a2dcb4914b3e0672249e82db6bff80cb2">parse_input_file</a>(<span class="stringliteral">&quot;/temp/BVP.csv&quot;</span>,float_track);</div></div><!-- fragment --><h2><a class="anchor" id="sequencechannels"></a>
Sequence Channels The Canvas of notes</h2>
<p>An <a class="el" href="class_i_sequence_channel.html">ISequenceChannel</a> is a canvas or "piano roll" where we can place notes and they will be performed either via a user defined NotePlayer or via a <a class="el" href="struct_process_slice.html" title="A process Slice passed to and from VST host to model facade. ">ProcessSlice</a> object that is compatible with VST or audio pluigin environments. A sequence channel can be created independently via the Model facade and they are also created automatically when creating a biometric signal processor (described below). The independent sequence channel is created as folows and requires a user implemented <a class="el" href="class_i_note_player.html">INotePlayer</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// helper function to print transport data</span></div><div class="line"><span class="keywordtype">void</span> printTransportData(<span class="keyword">const</span> <a class="code" href="struct_transport_state.html">TransportState</a> &amp;state) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;clock    : &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#a2b55a08742e392003b72d0b82c3967c3">clock</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;position : &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#ae7df0f28dfe8a19332c510edb8148c33">position</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;tempo    : &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#a47cdd93062e95cee0714193d4a4da884">tempo</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;frames   : &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#abb60c801d30a669f6a8eeea5ef6bc339">frames</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;islooping: &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#a28c606fb0f45f726a6b0d60924a4de63">isLooping</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;isplaying: &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#a621a60c2ea1aebbbf0815aca8d174043">isPlaying</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;load (s) : &quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#abdd7dda9defee83a02a5defe26c8423d">process_load</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;state flag :&quot;</span> &lt;&lt; state.<a class="code" href="struct_transport_state.html#a6a549066315dcfbd47e5dd5c747a56fd">change</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//helper function to print note data</span></div><div class="line"><span class="keywordtype">void</span> printNoteData(<a class="code" href="struct_i_note_object.html">INoteObject</a> note) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;frequency :&quot;</span> &lt;&lt; note.<a class="code" href="struct_i_note_object.html#a458bda9129efb431d428ece1b88abce9">frequency</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;duration  :&quot;</span> &lt;&lt; note.<a class="code" href="struct_i_note_object.html#a2c650b14578976685cb0502c69ccc31e">duration</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;velocity  :&quot;</span> &lt;&lt; note.<a class="code" href="struct_i_note_object.html#a9ffa6374d10f52f13f3ad781894817f8">velocity</a> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// test data</span></div><div class="line">NOTEMAP testOffNotes[10];</div><div class="line">NOTEMAP testOnNotes[10];</div><div class="line"><a class="code" href="struct_transport_state.html">TransportState</a> test_state_change[10];</div><div class="line"><a class="code" href="struct_transport_state.html">TransportState</a> test_play_states[10];</div><div class="line"></div><div class="line"><span class="comment">// A note player implementation tester</span></div><div class="line"><span class="keyword">class </span>NotePlayerImplementation : <span class="keyword">public</span> <a class="code" href="class_i_note_player.html">INotePlayer</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">  NotePlayerImplementation(<span class="keywordtype">int</span> channelid){</div><div class="line">    channel_number = channelid;</div><div class="line">  }</div><div class="line"> </div><div class="line">  ~NotePlayerImplementation() { printf( <span class="stringliteral">&quot;note player destruct \n&quot;</span>);}</div><div class="line"> </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_i_note_player.html#ab79083f0fe25fdbcd40ee66ef16c3e54">doConfigurationChange</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *skin, <span class="keywordtype">int</span> configID)<span class="keyword"> override </span>{</div><div class="line"> </div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_i_note_player.html#af9ea7bd07727271c3745298f8f091824">playNotes</a>(<span class="keyword">const</span> <a class="code" href="struct_note_event_buffer.html">NoteEventBuffer</a> &amp;notes,<span class="keyword">const</span> <a class="code" href="struct_transport_state.html">TransportState</a> state, <a class="code" href="class_i_sequence_channel.html">ISequenceChannel</a> * channel)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordtype">double</span> framestart = state.<a class="code" href="struct_transport_state.html#ae7df0f28dfe8a19332c510edb8148c33">position</a>;</div><div class="line">    <span class="keywordtype">double</span> frameend = state.<a class="code" href="struct_transport_state.html#ae7df0f28dfe8a19332c510edb8148c33">position</a> + calculateFrameWidth(state);</div><div class="line">    <span class="comment">//only do something if notes are present</span></div><div class="line">    <span class="keywordflow">if</span> (notes.<a class="code" href="struct_note_event_buffer.html#a5852dc74dd2e5475a8f979e0a79c5c0a">numberNoteOffs</a> == 0 &amp;&amp; notes.<a class="code" href="struct_note_event_buffer.html#a992e5e3c64422eb33a7c92eefdaab5a8">numberNoteOns</a> == 0) { return ;}</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;seq channel : &quot;</span> &lt;&lt; channel-&gt;<a class="code" href="class_i_maple_object.html#a700f4978676e376076caee949a188a1a">get_name</a>() &lt;&lt; <span class="stringliteral">&quot; ch id: &quot;</span> &lt;&lt; channel_number &lt;&lt; <span class="stringliteral">&quot; PPQstart: &quot;</span> &lt;&lt; framestart &lt;&lt; <span class="stringliteral">&quot; PPQend: &quot;</span> &lt;&lt; frameend &lt;&lt; std::endl;</div><div class="line">    printTransportData(state);</div><div class="line">    testOnNotes[channel_number].clear();</div><div class="line">    testOffNotes[channel_number].clear();</div><div class="line">    test_play_states[channel_number] = state;</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0 ; i &lt; notes.<a class="code" href="struct_note_event_buffer.html#a992e5e3c64422eb33a7c92eefdaab5a8">numberNoteOns</a> ; ++i ) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;NOTE ON : &quot;</span> &lt;&lt; notes.<a class="code" href="struct_note_event_buffer.html#ae9589ed69352239586b4a92c6b15a5e8">noteOns</a>[i].<a class="code" href="struct_note_stack_instance.html#a349cfaeed6671ef6210658035fd43dec">hitPPQ</a> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j&lt; notes.<a class="code" href="struct_note_event_buffer.html#ae9589ed69352239586b4a92c6b15a5e8">noteOns</a>[i].<a class="code" href="struct_note_stack_instance.html#a3057f9ce39fcfb56d7207f5a08650852">noteStackSize</a>; j++) {</div><div class="line">            printNoteData(notes.<a class="code" href="struct_note_event_buffer.html#ae9589ed69352239586b4a92c6b15a5e8">noteOns</a>[i].<a class="code" href="struct_note_stack_instance.html#adfea11b8bc2516886a36d200ca0d3874">noteStack</a>[j]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0 ; i &lt; notes.<a class="code" href="struct_note_event_buffer.html#a5852dc74dd2e5475a8f979e0a79c5c0a">numberNoteOffs</a> ; ++i ) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;NOTE OFFS : &quot;</span> &lt;&lt; notes.<a class="code" href="struct_note_event_buffer.html#abf701bc6444a24ba49fc5d052161c446">noteOffs</a>[i].<a class="code" href="struct_note_stack_instance.html#a349cfaeed6671ef6210658035fd43dec">hitPPQ</a> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j&lt; notes.<a class="code" href="struct_note_event_buffer.html#abf701bc6444a24ba49fc5d052161c446">noteOffs</a>[i].<a class="code" href="struct_note_stack_instance.html#a3057f9ce39fcfb56d7207f5a08650852">noteStackSize</a>; j++) {</div><div class="line">            printNoteData(notes.<a class="code" href="struct_note_event_buffer.html#abf701bc6444a24ba49fc5d052161c446">noteOffs</a>[i].<a class="code" href="struct_note_stack_instance.html#adfea11b8bc2516886a36d200ca0d3874">noteStack</a>[j]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_i_note_player.html#a2453c79eeb7b39ad98a7f0afa16e0e5f">processTransportStateChange</a>(<span class="keyword">const</span> <a class="code" href="struct_transport_state.html">TransportState</a> state, <a class="code" href="class_i_sequence_channel.html">ISequenceChannel</a> * channel)<span class="keyword"> override </span>{</div><div class="line">    test_state_change[channel_number] = state;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TRANSPORT CHANGE EVENT seq channel : &quot;</span> &lt;&lt; channel-&gt;<a class="code" href="class_i_maple_object.html#a700f4978676e376076caee949a188a1a">get_name</a>() &lt;&lt; <span class="stringliteral">&quot; ch id &quot;</span> &lt;&lt; channel_number &lt;&lt;std::endl;</div><div class="line">    printTransportData(state);</div><div class="line">  }</div><div class="line"> </div><div class="line"> </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="class_i_note_player.html#a1384b183e72b689731d2d1ddf4d82814">setChannelId</a>(<span class="keywordtype">int</span> cid)<span class="keyword"> override </span>{</div><div class="line">    channel_number = cid;</div><div class="line">  }</div><div class="line"> </div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="class_i_note_player.html#a344d841dc9bf08a74d2e7a099ec0838d">getChannelId</a>()<span class="keyword"> override </span>{</div><div class="line">     <span class="keywordflow">return</span> channel_number;</div><div class="line">  }</div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">int</span> channel_number;</div><div class="line"> </div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// create a sequence channel and noteplayer</span></div><div class="line"></div><div class="line">  <a class="code" href="class_i_maple_model.html">IMapleModel</a> *testModel = <a class="code" href="namespacemedimuse.html#ac814201971ebf4c41fa1b3076d852372">create_maple_model</a>(44100);</div><div class="line"> </div><div class="line"></div><div class="line">  std::shared_ptr&lt;NotePlayerImplementation&gt; np1 = std::make_shared&lt;NotePlayerImplementation&gt;(0);</div><div class="line"></div><div class="line">  <a class="code" href="class_i_sequence_channel.html">ISequenceChannel</a>* seq_fubar_1 =  testModel-&gt;<a class="code" href="class_i_maple_model.html#a09e189798ef81cb6029ab797ea57e8e2">create_sequence_channel</a>(<span class="stringliteral">&quot;Fubar 1&quot;</span>, np1.get());</div><div class="line"> </div><div class="line">  testModel-&gt;<a class="code" href="class_i_maple_model.html#a690954c01aa1598fc31d20dff5695019">set_render_mode</a>();</div><div class="line"></div><div class="line">  <span class="comment">// create a little test sequence</span></div><div class="line"></div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> A6 = NOTE(1760.0,<a class="code" href="_i_note_object_8h.html#ac002dc43871dd4a65c6078c89f6b7d11">WHOLE_NOTE</a>,0.5);</div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> A5 = NOTE(880.0,<a class="code" href="_i_note_object_8h.html#aebee59b130efa29c8fae1a6edf0eb6da">HALF_NOTE</a>,0.5);</div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> A4 = NOTE(440.0,<a class="code" href="_i_note_object_8h.html#a38b64a83d40efc9bd98f4b187d1544c4">QUARTER_NOTE</a>,0.5);</div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> A3 = NOTE(220.0,<a class="code" href="_i_note_object_8h.html#acba365e40133d2ca30ef441f043eb5ce">EIGHTH_NOTE</a>,0.5);</div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> A2 = NOTE(110.0,<a class="code" href="_i_note_object_8h.html#a14b2b8135ea87cce635439021c2979f7">SIXTEENTH_NOTE</a>,0.5);</div><div class="line"></div><div class="line">  <a class="code" href="struct_note_stack_instance.html">NoteStackInstance</a> beat1;</div><div class="line">  <a class="code" href="struct_i_note_object.html">INoteObject</a> stack1[5] = {A2,A3,A4,A5,A6};</div><div class="line">  beat1.<a class="code" href="struct_note_stack_instance.html#a349cfaeed6671ef6210658035fd43dec">hitPPQ</a> = 0.0;</div><div class="line">  beat1.<a class="code" href="struct_note_stack_instance.html#adfea11b8bc2516886a36d200ca0d3874">noteStack</a> = stack1;</div><div class="line">  beat1.<a class="code" href="struct_note_stack_instance.html#a3057f9ce39fcfb56d7207f5a08650852">noteStackSize</a> = 5;</div><div class="line"></div><div class="line">  seq_fubar_1-&gt;addNotes(beat1);</div></div><!-- fragment --><h2><a class="anchor" id="transport"></a>
Looping Transport and the Orchestration of Sequence Channels</h2>
<p>DAW users will be familiar with the notion of a "transport". This is the main timing and control element of the playback of musical data. The <a class="el" href="class_i_looping_transport.html" title="A looping transport allows play / pause, looping , seeking capabilities for a sequence or track...">ILoopingTransport</a> is responsible for controlling the musical sequencing and timing. Currently one cannot create a transport directly but there is one that is created as a singleton contained in each model that is created. The "master" transport for the model can be retrived and manipulated:</p>
<div class="fragment"><div class="line"><a class="code" href="class_i_maple_model.html">IMapleModel</a> *testModel = <a class="code" href="namespacemedimuse.html#ac814201971ebf4c41fa1b3076d852372">create_maple_model</a>(12000);</div><div class="line"></div><div class="line"><span class="comment">// set the model to play</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a34bfaeb76489f80f5715e301d22f4ab7">resume</a>();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;********** PLAY FOR &quot;</span> &lt;&lt; NUM_SECONDS &lt;&lt;<span class="stringliteral">&quot; SECONDS *************&quot;</span> &lt;&lt;std::endl ;</div><div class="line">std::this_thread::sleep_for(sec);</div><div class="line"></div><div class="line"><span class="comment">// pause the transport</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#ab64de97492be49449fd1104222052a61">pause</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;********** PAUSE FOR &quot;</span> &lt;&lt; NUM_SECONDS &lt;&lt;<span class="stringliteral">&quot; SECONDS *************&quot;</span> &lt;&lt;std::endl ;</div><div class="line">std::this_thread::sleep_for(sec);</div><div class="line"></div><div class="line"><span class="comment">// set the tempo to 40 beats per minute</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a32cda45f784285b91fe83c93b658d8ef">set_tempo</a>(40.0);</div><div class="line"></div><div class="line"><span class="comment">// resume the transport at the new tempo</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a34bfaeb76489f80f5715e301d22f4ab7">resume</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;********** PLAY FOR &quot;</span> &lt;&lt; NUM_SECONDS &lt;&lt;<span class="stringliteral">&quot; SECONDS *************&quot;</span> &lt;&lt;std::endl ;</div><div class="line">std::this_thread::sleep_for(sec);</div><div class="line"></div><div class="line"></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#ab64de97492be49449fd1104222052a61">pause</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;********** PAUSE FOR &quot;</span> &lt;&lt; NUM_SECONDS &lt;&lt;<span class="stringliteral">&quot; SECONDS *************&quot;</span> &lt;&lt;std::endl ;</div><div class="line">std::this_thread::sleep_for(sec);</div><div class="line"></div><div class="line"><span class="comment">// seek to PPQ position 0.0</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#ac492d05bfc96ef29183073346481157e">seek</a>(0.0);</div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a32cda45f784285b91fe83c93b658d8ef">set_tempo</a>(96.0);</div><div class="line"></div><div class="line"><span class="comment">// set loop settings and set the master transport to loop</span></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a99ac93cec8705655db3244fc5a47662e">set_loop_start</a>(0.0);</div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#aea0f60a9691eb40e12d7bac0333c0124">set_loop_length</a>(4.0);</div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a49a3d64b21d5aa8789e3410cd8e21989">set_looping</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">testModel-&gt;<a class="code" href="class_i_maple_model.html#a8ea1bef77071735d8576bf7bc440ca05">get_master_transport</a>()-&gt;<a class="code" href="class_i_looping_transport.html#a34bfaeb76489f80f5715e301d22f4ab7">resume</a>();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;********** PLAY FOR &quot;</span> &lt;&lt; NUM_SECONDS &lt;&lt;<span class="stringliteral">&quot; SECONDS *************&quot;</span> &lt;&lt;std::endl ;</div><div class="line">std::this_thread::sleep_for(sec);</div></div><!-- fragment --><p>TODO:// independent looping transports, we will allow the ability of individual sequence channels to be operated with idependent transports this means each channel can be play / paused and looped independent of the master transport. This is borrowed from Liquid Music VST (created by this author) and from the notion of a "clip" in the Ableton DAW space. This will allow more interesting sequencing creations.</p>
<h2><a class="anchor" id="biometricproccesors"></a>
Biometric Signal Processors, where the magic happens</h2>
<p>Clearly the biometric signal processor is where the rubber meets the road for the Medimuse Statesong patented process. The intention is that this will eventually be a fully developed plugin specification, currently the <a class="el" href="class_i_bio_signal_processor.html">IBioSignalProcessor</a> is a framework to allow developers to "interpret" the biometric signals incoming and presented with a sequence channel canvas on which to paint this interpretation. The original prototype it was clear that the processor had to have both a rhythmic and a melodic sequence channel in order to have a proper separation in the sense of percussive and melodic instruments. The processors are also equipped with a subscribe and publish notification mechanism where messages can be passed between different processors. For example the original prototype (Android / Java) the heart rate processor published the changed in heart rate, this publication was used in other processors to adjust melodic tones and the tempo of the transport. The <a class="el" href="class_i_note_player.html">INotePlayer</a> implementation is from the examples above</p>
<div class="fragment"><div class="line"><span class="comment">// and implementation of a biosignal processor call back object</span></div><div class="line"><span class="keyword">class </span>BioSignalCallbackImplemetation : <span class="keyword">public</span> <a class="code" href="class_i_bio_signal_processor_callback.html">IBioSignalProcessorCallback</a>&lt;float&gt; {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    BioSignalCallbackImplemetation(){}</div><div class="line">    ~BioSignalCallbackImplemetation(){}</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_i_bio_signal_processor_callback.html#a1c0b80bb0a27ef1349906c4ed8d9a297">process_data_point</a>(<a class="code" href="class_i_input_signal.html">IInputSignal&lt;float&gt;</a> * signal, <a class="code" href="class_i_bio_signal_processor.html">IBioSignalProcessor&lt;float&gt;</a> *processor, <span class="keyword">const</span> <span class="keywordtype">float</span> data[], int64_t timeStamp)<span class="keyword"> override </span>{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DATA TICK&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; signal-&gt;<a class="code" href="class_i_input_signal.html#a275cb0236ffc5cac252be05af6be7eca">get_dimensionality</a>();i++) {</div><div class="line">            test_data[i] = data[i];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_i_bio_signal_processor_callback.html#a608416ca4bc1a3318ad5549e3e80cd05">process_state_message</a>(<a class="code" href="class_i_state_message.html">IStateMessage</a> *msg)<span class="keyword"> override </span>{</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">    <span class="comment">// a melodic noteplayer</span></div><div class="line">    NotePlayerImplementation np_test_m(0);</div><div class="line">    <span class="comment">// a rhythmic note player</span></div><div class="line">    NotePlayerImplementation np_test_r(1);</div><div class="line"></div><div class="line">    BioSignalCallbackImplemetation bio_callback;</div><div class="line"> </div><div class="line">    <a class="code" href="class_i_maple_model.html">IMapleModel</a> *testm = <a class="code" href="namespacemedimuse.html#ac814201971ebf4c41fa1b3076d852372">create_maple_model</a>(44100.0);</div><div class="line">    <a class="code" href="class_i_input_signal.html">IInputSignal&lt;float&gt;</a> *test_in =  testm-&gt;<a class="code" href="class_i_maple_model.html#a411929f6d5f1f02ca1b1a3f29f3900c3">create_float_input_signal</a>(<span class="stringliteral">&quot;Test Signal&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969eaa6cd1d230aaca43e44f87cd2aab71c83">BioSignalType::ACC</a>, 1, 4.0);</div><div class="line">    <a class="code" href="class_i_input_signal.html">IInputSignal&lt;float&gt;</a> *test_in2 =  testm-&gt;<a class="code" href="class_i_maple_model.html#a411929f6d5f1f02ca1b1a3f29f3900c3">create_float_input_signal</a>(<span class="stringliteral">&quot;Test Signal&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969ea05e46fda0c33b54f2b4d1023e0d56c14">BioSignalType::BVP</a>, 3, 4.0);</div><div class="line"></div><div class="line">    <span class="comment">// create a couple biosignal processors</span></div><div class="line">    <a class="code" href="class_i_bio_signal_processor.html">IBioSignalProcessor&lt;float&gt;</a> *bio_floater =  testm-&gt;<a class="code" href="class_i_maple_model.html#a82cc232ba6416351067f84be173ca751">create_float_biosignal_processor</a>(<span class="stringliteral">&quot;ACC-PROC&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969eaa6cd1d230aaca43e44f87cd2aab71c83">BioSignalType::ACC</a>, &amp;np_test_m, &amp;np_test_r, &amp;bio_callback);</div><div class="line">    <a class="code" href="class_i_bio_signal_processor.html">IBioSignalProcessor&lt;float&gt;</a> *bio_floater2 =  testm-&gt;<a class="code" href="class_i_maple_model.html#a82cc232ba6416351067f84be173ca751">create_float_biosignal_processor</a>(<span class="stringliteral">&quot;BVP-PROC&quot;</span>, <a class="code" href="_global_types_8h.html#ace464cca3799348abcc9029fe2e9969ea05e46fda0c33b54f2b4d1023e0d56c14">BioSignalType::BVP</a>, &amp;np_test_m, &amp;np_test_r, &amp;bio_callback);</div><div class="line"></div><div class="line">    <span class="comment">// the first processor will subscribe to the second processor publications</span></div><div class="line"> </div><div class="line">    bio_floater-&gt;<a class="code" href="class_i_bio_signal_processor.html#ae2a8ea12bf4d858282cb0f813bb71da1">subscribe_to_processor_broadcast</a>(bio_floater2);</div></div><!-- fragment --><h2><a class="anchor" id="audiotiming"></a>
Audio Timing, Real time and Render Modes of operation</h2>
<p>All of the timing is controlled via one entry point into the model. A <a class="el" href="struct_process_slice.html" title="A process Slice passed to and from VST host to model facade. ">ProcessSlice</a> is presented for each frame (or collection of audio ticks) and passed to the model , typically on the audio thread of a real audio stream. For this type of operation (real time) the model is set to real time mode and the computer clock is taken form the real time of the computer. In render mode the operation is identical however tyipcally the entry pojnt is not called by a time controlled audio device. This mode is presented in order to render music at a faster rate than what can be acvied with an audio device clock.</p>
<p>Here is an example using the <a class="el" href="class_i_maple_model.html" title="Class IMapleModel base class and interface file for MapleModel. ">IMapleModel</a> inside an RTAudio callback function, the model was created previously and put in the user deata of the RTAudio callback:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> callBack( <span class="keywordtype">void</span> *outputBuffer, <span class="keywordtype">void</span> *inputBuffer,</div><div class="line">                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nFrames,</div><div class="line">                                <span class="keywordtype">double</span> streamTime,</div><div class="line">                                RtAudioStreamStatus status,</div><div class="line">                                <span class="keywordtype">void</span> *userData ) {</div><div class="line">    <span class="comment">// get the model form the user data</span></div><div class="line">    <a class="code" href="class_i_maple_model.html">IMapleModel</a> * model = (<a class="code" href="class_i_maple_model.html">IMapleModel</a> *) userData;</div><div class="line">    <span class="comment">// do a little conversion dance here to translate from Process slice to RTAudioStream</span></div><div class="line">    <a class="code" href="struct_process_slice.html">ProcessSlice</a> p;</div><div class="line">    <a class="code" href="struct_maple_audio_buffer.html">MapleAudioBuffer</a> in_buffer,out_buffer;</div><div class="line">    p.<a class="code" href="struct_process_slice.html#a1c83212a51b227028a9514b93bb57596">input_bus_size</a> = 0;</div><div class="line">    p.<a class="code" href="struct_process_slice.html#a271159b288955ea017d3f7754d302216">output_bus_size</a> = 1;</div><div class="line"></div><div class="line">    p.<a class="code" href="struct_process_slice.html#aef537784b37b4c3adf383df46a43ff9a">inputs</a> = <span class="keyword">nullptr</span>;</div><div class="line">    <a class="code" href="struct_maple_audio_buffer.html">MapleAudioBuffer</a> outs_1;</div><div class="line">    <a class="code" href="struct_maple_audio_buffer.html">MapleAudioBuffer</a> *bus1[1] = {&amp;outs_1};</div><div class="line">    p.<a class="code" href="struct_process_slice.html#a3f80b124584566bbb42827fe4ffd7f7e">outputs</a> = bus1[0];</div><div class="line"> </div><div class="line">    outs_1.<a class="code" href="struct_maple_audio_buffer.html#a9a312c375eadd64e993289447ad76258">channel_size</a>=2;</div><div class="line">    outs_1.<a class="code" href="struct_maple_audio_buffer.html#a2634f56ab0e0ade1be2eda26cd665c3c">float_channel_buffers</a> = (<span class="keywordtype">float</span>**) outputBuffer;</div><div class="line"> </div><div class="line">    p.<a class="code" href="struct_process_slice.html#ae4d06c4413fefa196f18a0a7817eaa14">sample_size</a>=nFrames;</div><div class="line"> </div><div class="line">    <span class="comment">// call the model to process the current tick</span></div><div class="line">    model-&gt;<a class="code" href="class_i_maple_model.html#a219057d9ecdd18c40826b1d308c17c45">framed_timer_tick</a>(p);</div><div class="line">    <span class="keywordflow">return</span> callback_rtn.load(); <span class="comment">// we can return 1 here to flush the buffers and halt or 2 to halt immeadiately</span></div><div class="line">}</div></div><!-- fragment --><p>Peter J Slack <a href="#" onclick="location.href='mai'+'lto:'+'psl'+'ac'+'k@p'+'js'+'lac'+'k.'+'com'; return false;">pslac<span style="display: none;">.nosp@m.</span>k@pj<span style="display: none;">.nosp@m.</span>slack<span style="display: none;">.nosp@m.</span>.com</a> 7:29 PM (1 hour ago) to Peter, Phil, MediMuse</p>
<p>.. also this </p><pre class="fragment">MAPLEMUSE_API void destroy_model(IMapleModel *model) {

    if (model == nullptr) { return; }

    std::lock_guard&lt;std::mutex&gt; lk(modelStackMapGuard);

    for (auto iter = modelStack.begin(); iter != modelStack.end() ; iter++) {

        std::shared_ptr&lt;MapleProcessModel&gt; i = *iter;

        if (i.get() == model) {

            modelStack.erase(iter);

            break;

        }

    }

}



MAPLEMUSE_API IMapleModel *find_maple_model(const char * uuid) {

    if (uuid == nullptr) { return nullptr; }

    std::string UuId(uuid);

    std::lock_guard&lt;std::mutex&gt; lk(modelStackMapGuard);

    for (auto model:modelStack) {

        std::string muuid(model.get()-&gt;get_maple_uuid());

        if (muuid == UuId) {

            return dynamic_cast&lt;IMapleModel*&gt;(model.get());

        }

    }

    return nullptr;

}</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
